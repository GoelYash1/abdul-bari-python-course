1. dir can be used to find methods of a class dir(str)
2. help can be used to find how to apply a function help(input)
3. index and find difference is index will give error if a substring doesn't exist in the string, whereas find will output -1
4. If you use two print statements and don't want the next print to be in a new line then you can:
    print("abc",end="")
    print("def")
    output: abcdef
5. print has print(end="\n", sep = " ", flush = False, file = sys.stdout ) DEFAULTS and more
    flush is a higher concept something related to buffer
6. Sets cannot contain mutable objects
        s = {{1,2,3},[1,2,3]} not allowed
        s = {1,(2,3),"Hello", 45.67} allowed
7. * is used to make arguments to its right in function key word based and * cannot be at the end
   / is used to make arguments to its left in function positional based and / cannot be at the start
   fun(a,b,/,c,d) means fun(a=1,b=2,c=3,d=4) is wrong as a and b cannot be key word based
   fun(a,b,*,c,d) means fun(1,2,3,4) is wrong as c and d cannot be written without key word mentioned
8. def fun(*args,a,b):
    print(args)
   args is a tuple and a and b are key word only
   i.e fun(1,2,3,4,5) IS WRONG, fun(1,2,3,a=4,b=5) IS CORRECT
-> def fun(**kwargs):
    print(kwargs)
   kwargs is a map and all the arguments are key word only
   i.e fun(1,2,3) IS WRONG, fun(a=1,b=2,c=3) IS CORRECT
-> def fun(*args, a, b, **kwargs):
        print(args,a,b,kwargs)
   fun(1,2,3,a=1,b=2,c=4,d=5)
9. functions are also objects for example show = print
    i.e show("Hello") is same as print("Hello")
10. def fun():
        count = 0
        def counter():
            nonlocal count
            count+=1
        return counter
    This is a closure function and nonlocal is used to update the count on repeated calls like
    c1 = fun()
    print(c1(), c1(), c1()) # 1 2 3
11. ZeroDivisionError, TypeError, IndexError, KeyError,     ValueError
    10/0               10/'x'     l = [1,2]   d = {1:'one'} int('xyz')
                                  l[4]        d[2]
